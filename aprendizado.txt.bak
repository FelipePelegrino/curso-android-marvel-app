-> O que estou aprendendo de novo/reforçando melhor com o curso?

	• Novidade e utilização do detekt (ferramenta de analise estatica de codigo)
	
	• Modularização do app, quais os motivos?
		- Build mais performático (só builda os arquivos do modulo alterado)
		- Estrutura e facilitação na organização do código (encaixa muito bem com Clean Architecture)
		- Como trazer as dependencias de um modulo para outro
		
	• Utilização do httplogging para apresentar os dados no log apenas quando for debug
	
	• Melhor utilização do interceptor para definir as chaves de api e url base
	
	• Uma das formas segures de armazenar apiKeys no android ->
		- apikey.properties
		- BuildConfig
		
	• Utilização consciente do principio L do soLid, principio da substituição por interface (Liskov)
		- utilização através da clean, definindo os métodos de acesso a dados remoto, e a api volátil implementa essas regras
		- Criando interfaces para definir os métodos de acesso a dados remoto/local na camada core, e implementando com os frameworks volateis na camada app
		
	• Como utilizar o hilt para:
		- Prover dependencias de classes que "não são minhas" | Provide | Object
		- Prover dependencias de interfaces que são minhas | Binds | Interface
		
	• Use cases:
		- Faz toda a conversão/ponte entre camada de dados e camada de UI
		- Corresponde a somente um caso de uso, um unico fluxo, uma unica ação
	
	• Configuração de um Paging3 com Clean Architecutre (UseCase + Interface sobre repository/datasource + flow)
	
	• Utilização de Paging com Footer/Header observando o LoadState para implementar loading/error states
	
	• Testes unitários:
		- Como testar com o scopo de coroutines
		- Como criar um module para testes e fornecer através de uma classe através de @Rule, funções em comuns para todos os testes (Como a manipulação de coroutines)
		- Como o mockito funciona
			♦ @Mock funciona apenas para interface
			♦ Para instanciar, é precisso o Runner do mockito anotado na classe de teste com @RunWith(MockitoJUnitRunner::class)
			♦ Ou se o Runner for outro como por exemplo o JUnitRunner, na função anotada com @Before, devo utilizar o código MockitoAnotations.initMock(this) para ela identificar o @Mock e instanciar
		- Definir retorno de funções, comportamentos dos mocks para manipular os testes
		- Como testar a implementação de Paging3
		- Como mockar adequadamente
		- Por que é importante uma boa arquitetura e a utilização de interfaces bem definidas no projeto
		
	• BuildTypes
		- Debug: facilitação e rapidez no desenvolvimento, compilação rapida, testes rápidos
		- Staging: simulação do app da loja, habilitando configurações de ofuscação e redução de código, versão disponibilizadas para QA
		- Release: configurações de ofuscação, redução, habilitadas, versão para loja
		
	• Ofuscação, redução de código, utilização do proguard-rules, R8
	
	• Funcionamento de uma esteira de CI/CD
		- Por que utilizar? Melhora a qualidade do código, uma vez que o Lint e detekt irão analisar o código a cada push/Pr configurado na CI, assim como realizará todos os testes unitários e instrumentados
		- Permite a geração de versões para o próprio bitrise ou integrado a firebase, assim como permite gerar versão direto na loja
		- Ou seja, garante qualidade, segurança, agilidade e otimização no processo de desenvolvimento
		
	• Como bloquear uma branch para apenas aceitar Pull Request, garantindo sempre o code review em branchs críticas como develop, staging, master